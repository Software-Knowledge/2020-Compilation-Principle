Lecture3-Parser
---

1. **输入**:程序文本/字符串s & **词法单元(token) 的规约**

![](img/lec3/1.png)

2. **输出**:词法单元流

# 1. 语法分析距离
![](img/lec3/2.png)

# 2. 语法分析阶段的主题

## 2.1. 上下文无关文法
![](img/lec3/3.png)

1. 我们需要递归来提升我们语言的能力。

## 2.2. 构建语法分析树
![](img/lec3/4.png)

1. 自顶向上构造：比较符合直观，但是能力有限
2. 自底向下构造：Knuth算法

## 2.3. 错误恢复
1. 报错
2. **恢复**：现在的程序是比较大的，如果直接停止编译则导致有多少错误就需要编译多少次，不合适。
3. 继续分析

# 3. 上下文无关文法(CFG, Context-Free Grammer, 上下文无关文法)
1. 上下文无关文法$G$是一个四元组$G=(T,N,P,S)$:
2. T是**终结符号(Terminal)**集合, 对应于词法分析器产生的词法单元;
3. N是**非终结符号(Non-terminal)**集合;
4. P是**产生式(Production)**集合;

$$
A \in N \rightarrow \alpha \in (T \cup N)*
$$

- 头部/左部(Head)$A$: **单个**非终结符，必须只有一个，这就是为什么我们称其为上下文无关文法，如果有多个则不符合上下文无关文法，会被成为上下文有关文法，但是几乎无法处理。
- 体部/右部(Body)$\alpha$: 终结符与非终结符构成的串, 也可以是空串$\epsilon$
5. S为开始(Start)符号。要求$S \in N$且唯一。

1. 一个符号要么是终结符号，要么是非终结符号
2. 终结符号表示到此为止，无法再进行替换

$$
G = (\{S\}, \{(, )\}, P, S) \\
S \rightarrow SS \\
S \rightarrow (S) \\
S \rightarrow () \\
$$

> 任意嵌套的所有匹配好的括号串

$$
G = (\{S\}, \{(a, b)\}, P, S) \\
S \rightarrow aSb \\
S \rightarrow \epsilon \\
$$

![](img/lec3/5.png)

P11